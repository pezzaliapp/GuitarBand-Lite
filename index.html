<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>GuitarBand Lite — Trainer & Tuner</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#121826;
      --panel2:#0f1624;
      --txt:#e8eefc;
      --muted:#9aa7c2;
      --acc:#5eead4;
      --acc2:#60a5fa;
      --bad:#fb7185;
      --ok:#34d399;
      --bd: rgba(255,255,255,.08);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 900px at 20% 0%, #1a2440 0%, transparent 55%),
                  radial-gradient(900px 700px at 90% 10%, #12304a 0%, transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    header{
      position: sticky; top:0; z-index:10;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,15,20,.92), rgba(11,15,20,.55));
      border-bottom:1px solid var(--bd);
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
    }
    .brand{display:flex; align-items:center; gap:10px; min-width: 220px;}
    .logo{
      width:38px; height:38px; border-radius:12px;
      background: linear-gradient(135deg, rgba(94,234,212,.25), rgba(96,165,250,.18));
      border:1px solid var(--bd);
      box-shadow: var(--shadow);
      display:grid; place-items:center;
      font-weight:800; letter-spacing:.5px;
    }
    .title{line-height:1.1}
    .title b{display:block; font-size:14px}
    .title span{display:block; font-size:12px; color:var(--muted)}
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      border:1px solid var(--bd);
      background: rgba(18,24,38,.55);
      padding: 8px 12px;
      border-radius: 999px;
      color: var(--txt);
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      border-color: rgba(94,234,212,.45);
      background: rgba(94,234,212,.10);
      box-shadow: 0 0 0 3px rgba(94,234,212,.08) inset;
    }
    main{
      padding: 16px;
      max-width: 1100px;
      margin: 0 auto;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }
    @media (max-width: 920px){
      .grid{grid-template-columns:1fr}
      .brand{min-width: unset}
    }
    .card{
      background: linear-gradient(180deg, rgba(18,24,38,.85), rgba(15,22,36,.75));
      border:1px solid var(--bd);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h2{
      margin: 0 0 10px;
      font-size: 14px;
      letter-spacing: .2px;
      color: var(--txt);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .muted{color:var(--muted); font-size:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .btn{
      border:1px solid var(--bd);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      font-weight:600;
      font-size: 13px;
    }
    .btn.primary{
      border-color: rgba(94,234,212,.45);
      background: rgba(94,234,212,.12);
    }
    .btn.secondary{
      border-color: rgba(96,165,250,.45);
      background: rgba(96,165,250,.12);
    }
    .btn.danger{border-color: rgba(251,113,133,.45); background: rgba(251,113,133,.10)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    input[type="range"]{width: 180px}
    input[type="number"], select{
      background: rgba(0,0,0,.18);
      border:1px solid var(--bd);
      color: var(--txt);
      padding: 9px 10px;
      border-radius: 12px;
      outline:none;
    }
    .big{
      font-size: 44px;
      font-weight: 900;
      letter-spacing: -1px;
      margin: 8px 0 0;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .pill.ok{border-color: rgba(52,211,153,.35); color: rgba(52,211,153,.92); background: rgba(52,211,153,.08)}
    .pill.warn{border-color: rgba(251,113,133,.35); color: rgba(251,113,133,.92); background: rgba(251,113,133,.08)}
    .meter{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--bd);
      overflow:hidden;
    }
    .meter > i{
      display:block;
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(251,113,133,.9), rgba(94,234,212,.9), rgba(251,113,133,.9));
      transform: translateX(-50%);
    }
    .chordBox{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 560px){ .chordBox{grid-template-columns:1fr} }
    .fret{
      width: 100%;
      max-width: 320px;
      border-radius: 14px;
      border:1px solid var(--bd);
      background: rgba(0,0,0,.18);
      padding: 10px;
    }
    canvas{width:100%; height:auto; display:block}
    .hint{
      font-size: 12px;
      color: var(--muted);
      margin-top:8px;
      line-height:1.35;
    }
    audio{width:100%}
    .hide{display:none}

    /* --- Drum machine UI --- */
    .steps{
      display:grid;
      grid-template-columns: 42px repeat(var(--nsteps, 16), 1fr);
      gap: 6px;
      align-items:center;
      margin-top: 10px;
      overflow:auto;
      padding-bottom: 6px;
    }
    .steps .lab{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      padding-right:6px;
      user-select:none;
      position:sticky;
      left:0;
      background: rgba(11,15,20,.35);
      border-radius: 10px;
    }
    .step{
      height: 20px;
      min-width: 18px;
      border-radius: 8px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      position:relative;
    }
    .step.on{
      border-color: rgba(96,165,250,.45);
      background: rgba(96,165,250,.16);
      box-shadow: 0 0 0 3px rgba(96,165,250,.06) inset;
    }
    .step.playhead::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 10px;
      border:2px solid rgba(94,234,212,.55);
      pointer-events:none;
    }

    /* --- Sequencer UI (accordi + corde) --- */
    .seqsteps{
      display:grid;
      grid-template-columns: 80px repeat(var(--nsteps, 16), 1fr);
      gap: 6px;
      align-items:center;
      margin-top: 10px;
      overflow:auto;
      padding-bottom: 6px;
    }
    .seqsteps .lab{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      padding-right:6px;
      user-select:none;
      white-space: nowrap;
      position:sticky;
      left:0;
      background: rgba(11,15,20,.35);
      border-radius: 10px;
    }
    .seqstep{
      height: 24px;
      min-width: 18px;
      border-radius: 9px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      position:relative;
      display:grid;
      place-items:center;
      font-size: 11px;
      color: rgba(232,238,252,.92);
      user-select:none;
      overflow:hidden;
    }
    .seqstep.on{
      border-color: rgba(94,234,212,.50);
      background: rgba(94,234,212,.12);
      box-shadow: 0 0 0 3px rgba(94,234,212,.06) inset;
    }
    .seqstep.chord{
      border-color: rgba(96,165,250,.35);
      background: rgba(96,165,250,.10);
    }
    .seqstep.playhead::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 11px;
      border:2px solid rgba(96,165,250,.55);
      pointer-events:none;
    }
    .tiny{
      font-size:11px;
      padding: 6px 10px;
      border-radius: 12px;
    }
  </style>
</head>

<body>
<header>
  <div class="brand">
    <div class="logo">GB</div>
    <div class="title">
      <b>GuitarBand Lite</b>
      <span>metronomo • accordi • tuner • studio/loop</span>
    </div>
  </div>
  <div class="tabs">
    <div class="tab active" data-view="practice">Practice</div>
    <div class="tab" data-view="tuner">Tuner</div>
    <div class="tab" data-view="studio">Studio</div>
  </div>
</header>

<main>
  <!-- PRACTICE -->
  <section id="view-practice" class="grid">
    <div class="card">
      <h2>
        Trainer accordi
        <span class="pill" id="trainerStatus">pronto</span>
      </h2>

      <div class="chordBox">
        <div>
          <div class="row">
            <label class="muted">Accordo</label>
            <select id="chordSelect"></select>
            <button class="btn" id="nextChord">Prossimo</button>

            <button class="btn primary" id="playChord">Play</button>
            <select id="strum">
              <option value="down">↓ down</option>
              <option value="up">↑ up</option>
              <option value="arp">arp</option>
            </select>
          </div>
          <div class="big" id="chordName">—</div>
          <div class="hint" id="chordHint">Seleziona un accordo e prova a suonarlo a tempo.</div>
        </div>

        <div class="fret">
          <canvas id="fretCanvas" width="480" height="320"></canvas>
          <div class="hint">Diagramma semplice (capotasto in alto). “X” = corda muta, “0” = corda a vuoto.</div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid var(--bd);margin:14px 0">

      <div class="row">
        <button class="btn primary" id="startTrainer">Avvia sessione</button>
        <button class="btn" id="stopTrainer" disabled>Stop</button>

        <label class="muted">Cambio ogni</label>
        <input type="number" id="changeEvery" value="20" min="5" max="120" style="width:90px">
        <span class="muted">sec</span>

        <label class="muted">Set</label>
        <select id="chordSet">
          <option value="basic">Base (Em Am C G D)</option>
          <option value="open">Open (E A D G C F Am Em Dm)</option>
          <option value="all">Tutti</option>
        </select>
      </div>
    </div>

    <div class="card">
      <h2>Metronomo / Groove</h2>

      <div class="row">
        <button class="btn primary" id="metroToggle">Metronomo: On</button>
        <label class="muted">BPM</label>
        <input type="range" id="bpm" min="40" max="220" value="76">
        <input type="number" id="bpmNum" min="40" max="220" value="76" style="width:90px">
        <label class="muted">Time</label>
        <select id="sig">
          <option value="4">4/4</option>
          <option value="3">3/4</option>
          <option value="6">6/8</option>
        </select>
      </div>
      <div class="hint">Ora il click è schedulato sul clock audio (sincronizzato con Drum/Sequencer).</div>

      <hr style="border:none;border-top:1px solid var(--bd);margin:14px 0">

      <h2>Drone (tonica)</h2>
      <div class="row">
        <select id="droneNote">
          <option value="110">A2 (110 Hz)</option>
          <option value="146.83">D3 (146.83 Hz)</option>
          <option value="196">G3 (196 Hz)</option>
          <option value="261.63">C4 (261.63 Hz)</option>
          <option value="329.63">E4 (329.63 Hz)</option>
        </select>
        <button class="btn" id="droneToggle">On/Off</button>
        <label class="muted">Volume</label>
        <input type="range" id="droneVol" min="0" max="1" step="0.01" value="0.18">
      </div>
      <div class="hint">Il drone aiuta l’orecchio: suona scale/accordi sopra una nota fissa.</div>

      <hr style="border:none;border-top:1px solid var(--bd);margin:14px 0">

      <h2>Drum machine (16/32 step)</h2>
      <div class="row">
        <button class="btn primary" id="drumToggle">Drum: On</button>
        <label class="muted">Swing</label>
        <input type="range" id="swing" min="0" max="0.6" step="0.01" value="0.10">
        <label class="muted">Vol</label>
        <input type="range" id="drumVol" min="0" max="1" step="0.01" value="0.65">
        <span class="pill" id="drumStepsInfo">16 step</span>
      </div>
      <div class="hint">Loop: 1 o 2 battute. Se passi a 2 battute, compaiono 32 step.</div>

      <div class="steps" id="stepGrid"></div>
    </div>
  </section>

  <!-- TUNER -->
  <section id="view-tuner" class="grid hide">
    <div class="card">
      <h2>
        Tuner (microfono)
        <span class="pill" id="micStatus">microfono: off</span>
      </h2>
      <div class="row">
        <button class="btn primary" id="micToggle">Attiva microfono</button>
        <button class="btn" id="micStop" disabled>Disattiva</button>
        <span class="muted">Suggerimento: pizzica una corda singola, niente accordo.</span>
      </div>

      <div style="margin-top:10px">
        <div class="muted">Nota rilevata</div>
        <div class="big" id="noteName">—</div>
        <div class="row">
          <span class="pill" id="freqRead">— Hz</span>
          <span class="pill" id="centsRead">— cents</span>
          <span class="pill" id="targetRead">target: —</span>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Intonazione</div>
          <div class="meter"><i id="meterBar"></i></div>
          <div class="hint">Al centro = in tono. A sinistra = basso, a destra = alto.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Accordatura standard (chitarra)</h2>
      <div class="row" style="gap:8px">
        <span class="pill">E2 82.41</span>
        <span class="pill">A2 110.00</span>
        <span class="pill">D3 146.83</span>
        <span class="pill">G3 196.00</span>
        <span class="pill">B3 246.94</span>
        <span class="pill">E4 329.63</span>
      </div>
      <div class="hint">Per iniziare: accorda E2 e A2 con calma: sono le più “sensibili” al rumore.</div>
    </div>
  </section>

  <!-- STUDIO -->
  <section id="view-studio" class="grid hide">
    <div class="card">
      <h2>
        Transport (tutto sincronizzato)
        <span class="pill" id="transportStatus">idle</span>
      </h2>

      <div class="row">
        <button class="btn primary" id="playAll">PLAY ALL</button>
        <button class="btn" id="stopAll" disabled>STOP</button>

        <label class="muted">Loop</label>
        <select id="loopLen">
          <option value="1">1 battuta (16 step)</option>
          <option value="2" selected>2 battute (32 step)</option>
        </select>

        <span class="pill" id="loopInfo">32 step</span>
        <span class="pill" id="flagsInfo">metro:on • drum:on • seq:on</span>
      </div>

      <div class="hint">
        Un solo clock audio pilota: metronomo, drum, accordi e corde.
        (Il microfono/rec è separato.)
      </div>

      <hr style="border:none;border-top:1px solid var(--bd);margin:14px 0">

      <h2>Sequencer — Accordi + 6 corde (step quantizzati)</h2>

      <div class="row">
        <label class="muted">Accordo</label>
        <select id="seqChordPick"></select>
        <button class="btn tiny" id="seqClearChords">Clear chords</button>
        <button class="btn tiny" id="seqFillChord">Fill loop</button>

        <span class="pill" id="seqInfo">step = 16th</span>
      </div>

      <div class="row" style="margin-top:8px">
        <label class="muted">Edit corde</label>
        <select id="stringPick">
          <option value="0">E (bassa)</option>
          <option value="1">A</option>
          <option value="2">D</option>
          <option value="3">G</option>
          <option value="4">B</option>
          <option value="5">E (alta)</option>
        </select>

        <label class="muted">Fret</label>
        <input type="number" id="fretPick" value="0" min="0" max="12" style="width:90px">

        <button class="btn tiny" id="seqClearStrings">Clear corde</button>

        <span class="pill">Click step = toggle (mette il fret selezionato)</span>
      </div>

      <div class="seqsteps" id="seqGrid"></div>

      <div class="row" style="margin-top:12px">
        <button class="btn secondary" id="seqToggle">Seq: On</button>
        <span class="pill" id="seqStatus">enabled</span>
      </div>

      <div class="hint">
        Riga CHORD: clic per assegnare l’accordo selezionato. <br>
        Righe corde: seleziona corda + fret, poi clic sugli step per inserire/levare la nota su quella corda.
      </div>
    </div>

    <div class="card">
      <h2>Studio (registrazione rapida)</h2>
      <div class="row">
        <button class="btn primary" id="recStart">Rec</button>
        <button class="btn danger" id="recStop" disabled>Stop</button>
        <span class="pill" id="recStatus">idle</span>
      </div>
      <div class="hint">
        Registra dal microfono (MediaRecorder → webm/ogg). Per registrare il “mix interno” serve una versione
        con MediaStreamDestination (posso aggiungerla).
      </div>

      <div style="margin-top:12px">
        <audio id="playback" controls></audio>
      </div>

      <hr style="border:none;border-top:1px solid var(--bd);margin:14px 0">

      <h2>Roadmap “GarageBand style”</h2>
      <ul class="muted" style="margin:0; padding-left: 18px; line-height:1.6">
        <li>Looper 1–2 battute con quantizzazione</li>
        <li>Registrazione del mix interno (WebAudio → MediaStreamDestination)</li>
        <li>Effetti: EQ + reverb + delay</li>
        <li>Multi-track con mute/solo e mix volumi</li>
      </ul>
    </div>
  </section>
</main>

<script>
/* =========================
   Audio engine basics
========================= */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}

/* =========================
   Tabs / Views
========================= */
const tabs = [...document.querySelectorAll('.tab')];
const views = {
  practice: document.getElementById('view-practice'),
  tuner: document.getElementById('view-tuner'),
  studio: document.getElementById('view-studio'),
};
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  const v = t.dataset.view;
  Object.entries(views).forEach(([k, el]) => el.classList.toggle('hide', k !== v));
}));

/* =========================
   UI refs
========================= */
const bpm = document.getElementById('bpm');
const bpmNum = document.getElementById('bpmNum');
const sig = document.getElementById('sig');

bpm.addEventListener('input', () => bpmNum.value = bpm.value);
bpmNum.addEventListener('input', () => bpm.value = bpmNum.value);

/* =========================
   Metronome (scheduled)
========================= */
let metroEnabled = true;
const metroBtn = document.getElementById('metroToggle');

function clickSoundAt(time, isAccent){
  const ctx = ensureAudio();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = 'square';
  o.frequency.setValueAtTime(isAccent ? 1400 : 980, time);

  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(isAccent ? 0.25 : 0.15, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);

  o.connect(g).connect(ctx.destination);
  o.start(time);
  o.stop(time + 0.07);
}
metroBtn.addEventListener('click', ()=>{
  metroEnabled = !metroEnabled;
  metroBtn.textContent = metroEnabled ? "Metronomo: On" : "Metronomo: Off";
  paintFlags();
});

/* =========================
   Drone (tonic)
========================= */
let droneOsc=null, droneGain=null;
const droneToggle = document.getElementById('droneToggle');
const droneNote = document.getElementById('droneNote');
const droneVol = document.getElementById('droneVol');

function droneOn(){
  const ctx = ensureAudio();
  droneOsc = ctx.createOscillator();
  droneGain = ctx.createGain();
  droneOsc.type = 'sine';
  droneOsc.frequency.value = Number(droneNote.value);
  droneGain.gain.value = Number(droneVol.value);
  droneOsc.connect(droneGain).connect(ctx.destination);
  droneOsc.start();
}
function droneOff(){
  try{ droneOsc && droneOsc.stop(); }catch(e){}
  droneOsc=null;
  droneGain=null;
}
droneToggle.addEventListener('click', ()=>{
  if(droneOsc){ droneOff(); }
  else { droneOn(); }
});
droneNote.addEventListener('change', ()=>{
  if(droneOsc){ droneOsc.frequency.value = Number(droneNote.value); }
});
droneVol.addEventListener('input', ()=>{
  if(droneGain){ droneGain.gain.value = Number(droneVol.value); }
});

/* =========================
   Chord library + diagram
========================= */
const CHORDS = {
  "Em": { fingering: ["0","2","2","0","0","0"], hint:"Em: classico, facile. Suona tutte le corde." },
  "Am": { fingering: ["X","0","2","2","1","0"], hint:"Am: attenzione a non stoppare la 1ª corda." },
  "C":  { fingering: ["X","3","2","0","1","0"], hint:"C: polso rilassato, dita arcuate." },
  "G":  { fingering: ["3","2","0","0","0","3"], hint:"G: prova anche variante con 2 dita su B e high E." },
  "D":  { fingering: ["X","X","0","2","3","2"], hint:"D: suona solo le ultime 4 corde." },
  "E":  { fingering: ["0","2","2","1","0","0"], hint:"E: come Em ma aggiungi il 1° dito al 1° tasto della 3ª corda." },
  "A":  { fingering: ["X","0","2","2","2","0"], hint:"A: prova a usare 3 dita o un mini barrè." },
  "Dm": { fingering: ["X","X","0","2","3","1"], hint:"Dm: punta delle dita, non schiacciare troppo." },
  "F":  { fingering: ["1","3","3","2","1","1"], hint:"F: barrè completo (difficile). Inizia con mini-barrè sulle prime 2 corde." },
};

const chordSelect = document.getElementById('chordSelect');
const chordName = document.getElementById('chordName');
const chordHint = document.getElementById('chordHint');
const nextChord = document.getElementById('nextChord');
const fretCanvas = document.getElementById('fretCanvas');
const ctx2d = fretCanvas.getContext('2d');

const chordSet = document.getElementById('chordSet');
function setOptions(list){
  chordSelect.innerHTML = "";
  list.forEach(k=>{
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k;
    chordSelect.appendChild(opt);
  });
}
function getSet(){
  const all = Object.keys(CHORDS);
  if(chordSet.value==="basic") return ["Em","Am","C","G","D"];
  if(chordSet.value==="open") return ["E","A","D","G","C","F","Am","Em","Dm"];
  return all;
}
setOptions(getSet());

chordSet.addEventListener('change', ()=>{
  setOptions(getSet());
  chordSelect.value = getSet()[0];
  renderChord(chordSelect.value);
});

function renderChord(name){
  const c = CHORDS[name];
  chordName.textContent = name;
  chordHint.textContent = c?.hint ?? "";
  drawFret(c?.fingering ?? ["X","X","X","X","X","X"]);
}

function drawFret(f){
  const W = fretCanvas.width, H = fretCanvas.height;
  ctx2d.clearRect(0,0,W,H);
  ctx2d.fillStyle = "rgba(0,0,0,.18)";
  ctx2d.fillRect(0,0,W,H);

  const pad = 42;
  const left = pad, top = pad;
  const right = W - pad, bottom = H - pad;
  const strings = 6, frets = 5;

  ctx2d.strokeStyle = "rgba(255,255,255,.25)";
  ctx2d.lineWidth = 3;
  for(let i=0;i<strings;i++){
    const x = left + (right-left) * (i/(strings-1));
    ctx2d.beginPath();
    ctx2d.moveTo(x, top);
    ctx2d.lineTo(x, bottom);
    ctx2d.stroke();
  }

  for(let j=0;j<=frets;j++){
    const y = top + (bottom-top) * (j/frets);
    ctx2d.strokeStyle = (j===0) ? "rgba(255,255,255,.50)" : "rgba(255,255,255,.20)";
    ctx2d.lineWidth = (j===0) ? 10 : 3;
    ctx2d.beginPath();
    ctx2d.moveTo(left, y);
    ctx2d.lineTo(right, y);
    ctx2d.stroke();
  }

  ctx2d.font = "bold 24px ui-sans-serif, system-ui";
  ctx2d.textAlign = "center";
  ctx2d.textBaseline = "middle";

  for(let i=0;i<6;i++){
    const x = left + (right-left) * (i/5);
    const v = f[i];
    if(v==="X" || v==="0"){
      ctx2d.fillStyle = "rgba(255,255,255,.85)";
      ctx2d.fillText(v, x, top - 20);
    } else {
      const fretNum = Number(v);
      const y = top + (bottom-top) * ((fretNum-0.5)/frets);
      ctx2d.fillStyle = "rgba(94,234,212,.95)";
      ctx2d.beginPath();
      ctx2d.arc(x, y, 18, 0, Math.PI*2);
      ctx2d.fill();
      ctx2d.fillStyle = "rgba(0,0,0,.75)";
      ctx2d.fillText(String(fretNum), x, y+1);
    }
  }
}

chordSelect.addEventListener('change', ()=> renderChord(chordSelect.value));
nextChord.addEventListener('click', ()=>{
  const list = getSet();
  const idx = list.indexOf(chordSelect.value);
  const next = list[(idx+1) % list.length];
  chordSelect.value = next;
  renderChord(next);
});

// init
chordSelect.value = getSet()[0];
renderChord(chordSelect.value);

/* =========================
   Guitar synth (strings + chord)
========================= */
// Standard tuning frequencies lowE..highE
const TUNING = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63];
const SEMI = Math.pow(2, 1/12);

function stringFretToFreq(stringIndex, fret){
  return TUNING[stringIndex] * Math.pow(SEMI, fret);
}

function pluck(ctx, freq, t, out, vel=0.18){
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  const f = ctx.createBiquadFilter();

  o.type = 'triangle';
  o.frequency.setValueAtTime(freq, t);
  o.detune.setValueAtTime((Math.random()*6-3), t);

  f.type = 'lowpass';
  f.frequency.setValueAtTime(2200, t);
  f.Q.setValueAtTime(0.8, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(vel, t + 0.008);
  g.gain.exponentialRampToValueAtTime(Math.max(0.04, vel*0.33), t + 0.10);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.55);

  o.connect(f).connect(g).connect(out);
  o.start(t);
  o.stop(t + 0.6);
}

let chordBusIn = null;
let chordOutGain = null;
function ensureChordBus(){
  const ctx = ensureAudio();
  if(chordBusIn) return chordBusIn;

  const comp = ctx.createDynamicsCompressor();
  comp.threshold.value = -18;
  comp.knee.value = 18;
  comp.ratio.value = 3.5;
  comp.attack.value = 0.005;
  comp.release.value = 0.12;

  chordOutGain = ctx.createGain();
  chordOutGain.gain.value = 0.95;

  comp.connect(chordOutGain).connect(ctx.destination);
  chordBusIn = comp;
  return chordBusIn;
}

function chordToFreqs(fingering){
  const freqs = [];
  for(let i=0;i<6;i++){
    const v = fingering[i];
    if(v === "X") continue;
    const fret = Number(v);
    freqs.push(stringFretToFreq(i, fret));
  }
  return freqs;
}

const playChordBtn = document.getElementById('playChord');
const strumSel = document.getElementById('strum');

function playChordAt(time, chordNameOverride=null){
  const ctx = ensureAudio();
  const busIn = ensureChordBus();
  const name = chordNameOverride || chordSelect.value;
  const fingering = CHORDS[name]?.fingering;
  if(!fingering) return;

  const freqs = chordToFreqs(fingering);
  const mode = strumSel.value;

  const bpmVal = Number(bpm.value || 76);
  const step = 60 / bpmVal / 8;

  let order = freqs.slice();
  if(mode === "up") order = order.reverse();

  const t0 = time ?? (ctx.currentTime + 0.02);
  order.forEach((fq, idx)=>{
    const dt = (mode === "arp") ? idx * (step*1.2) : idx * (step*0.5);
    pluck(ctx, fq, t0 + dt, busIn, 0.18);
  });
}
function playChordNow(){
  const ctx = ensureAudio();
  playChordAt(ctx.currentTime + 0.02);
}
playChordBtn.addEventListener('click', playChordNow);

/* =========================
   Trainer: auto-change chord
========================= */
let trainerTimer = null;
const startTrainer = document.getElementById('startTrainer');
const stopTrainer = document.getElementById('stopTrainer');
const changeEvery = document.getElementById('changeEvery');
const trainerStatus = document.getElementById('trainerStatus');

function trainerStart(){
  if(trainerTimer) return;
  trainerStatus.textContent = "in sessione";
  startTrainer.disabled = true;
  stopTrainer.disabled = false;

  const list = getSet();
  const step = () => {
    const rnd = list[Math.floor(Math.random()*list.length)];
    chordSelect.value = rnd;
    renderChord(rnd);
  };
  step();
  trainerTimer = setInterval(step, Number(changeEvery.value)*1000);
}
function trainerStop(){
  clearInterval(trainerTimer);
  trainerTimer = null;
  trainerStatus.textContent = "pronto";
  startTrainer.disabled = false;
  stopTrainer.disabled = true;
}
startTrainer.addEventListener('click', trainerStart);
stopTrainer.addEventListener('click', trainerStop);

/* =========================
   Loop length (1 or 2 bars)
========================= */
const loopLen = document.getElementById('loopLen');
const loopInfo = document.getElementById('loopInfo');
const drumStepsInfo = document.getElementById('drumStepsInfo');

function getLoopSteps(){
  return Number(loopLen.value) === 2 ? 32 : 16;
}
function updateLoopBadges(){
  const n = getLoopSteps();
  loopInfo.textContent = `${n} step`;
  drumStepsInfo.textContent = `${n} step`;
}

/* =========================
   Drum machine (16/32)
========================= */
const drumToggle = document.getElementById('drumToggle');
const swing = document.getElementById('swing');
const drumVol = document.getElementById('drumVol');
const stepGrid = document.getElementById('stepGrid');

const tracks = ["K","S","H"]; // kick, snare, hat
let drumEnabled = true;

// pattern is dynamic based on loop steps
let drumPattern = {
  K: Array(32).fill(false),
  S: Array(32).fill(false),
  H: Array(32).fill(false),
};

// default groove for first bar
[0,4,8,12].forEach(i=>drumPattern.K[i]=true);
[4,12].forEach(i=>drumPattern.S[i]=true);
[2,6,10,14].forEach(i=>drumPattern.H[i]=true);
// second bar: slightly varied default
[16,20,24,28].forEach(i=>drumPattern.K[i]=true);
[20,28].forEach(i=>drumPattern.S[i]=true);
[18,22,26,30].forEach(i=>drumPattern.H[i]=true);

let drumMaster = null;
function ensureDrumBus(){
  const ctx = ensureAudio();
  if(drumMaster) return drumMaster;
  drumMaster = ctx.createGain();
  drumMaster.gain.value = Number(drumVol.value || 0.65);
  drumMaster.connect(ctx.destination);
  return drumMaster;
}
drumVol.addEventListener('input', ()=>{ if(drumMaster) drumMaster.gain.value = Number(drumVol.value); });

function kick(time){
  const ctx = ensureAudio();
  const out = ensureDrumBus();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(150, time);
  o.frequency.exponentialRampToValueAtTime(55, time + 0.08);
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(0.9, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + 0.12);
  o.connect(g).connect(out);
  o.start(time);
  o.stop(time + 0.14);
}
function snare(time){
  const ctx = ensureAudio();
  const out = ensureDrumBus();

  const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

  const noise = ctx.createBufferSource();
  noise.buffer = noiseBuf;

  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 1200;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(0.35, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + 0.11);

  noise.connect(hp).connect(g).connect(out);
  noise.start(time);
  noise.stop(time + 0.12);

  const o = ctx.createOscillator();
  const og = ctx.createGain();
  o.type = 'triangle';
  o.frequency.setValueAtTime(210, time);
  og.gain.setValueAtTime(0.0001, time);
  og.gain.exponentialRampToValueAtTime(0.10, time + 0.004);
  og.gain.exponentialRampToValueAtTime(0.0001, time + 0.09);
  o.connect(og).connect(out);
  o.start(time);
  o.stop(time + 0.1);
}
function hat(time){
  const ctx = ensureAudio();
  const out = ensureDrumBus();

  const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

  const src = ctx.createBufferSource();
  src.buffer = noiseBuf;

  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 9000;
  bp.Q.value = 0.8;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(0.22, time + 0.002);
  g.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);

  src.connect(bp).connect(g).connect(out);
  src.start(time);
  src.stop(time + 0.06);
}

function buildDrumGrid(){
  const steps = getLoopSteps();
  stepGrid.style.setProperty('--nsteps', steps);
  stepGrid.innerHTML = "";

  tracks.forEach(tr=>{
    const lab = document.createElement('div');
    lab.className = "lab";
    lab.textContent = tr;
    stepGrid.appendChild(lab);

    for(let i=0;i<steps;i++){
      const d = document.createElement('div');
      d.className = "step" + (drumPattern[tr][i] ? " on" : "");
      d.dataset.tr = tr;
      d.dataset.i = String(i);
      d.addEventListener('click', ()=>{
        const t = d.dataset.tr;
        const idx = Number(d.dataset.i);
        drumPattern[t][idx] = !drumPattern[t][idx];
        d.classList.toggle('on', drumPattern[t][idx]);
      });
      stepGrid.appendChild(d);
    }
  });
}

function drumClearPlayhead(){
  stepGrid.querySelectorAll('.step.playhead').forEach(el=>el.classList.remove('playhead'));
}
function drumPaintPlayhead(stepIndex){
  drumClearPlayhead();
  const steps = getLoopSteps();
  tracks.forEach((tr, row)=>{
    const flatIndex = row * (1 + steps) + 1 + stepIndex; // label + steps
    const el = stepGrid.children[flatIndex];
    if(el) el.classList.add('playhead');
  });
}

drumToggle.addEventListener('click', ()=>{
  drumEnabled = !drumEnabled;
  drumToggle.textContent = drumEnabled ? "Drum: On" : "Drum: Off";
  paintFlags();
});

/* =========================
   Sequencer: CHORD lane + 6-string lanes
========================= */
const seqChordPick = document.getElementById('seqChordPick');
const seqClearChords = document.getElementById('seqClearChords');
const seqFillChord = document.getElementById('seqFillChord');
const seqClearStrings = document.getElementById('seqClearStrings');
const seqGrid = document.getElementById('seqGrid');
const seqStatus = document.getElementById('seqStatus');
const seqInfo = document.getElementById('seqInfo');

const seqToggle = document.getElementById('seqToggle');
let seqEnabled = true;

const stringPick = document.getElementById('stringPick');
const fretPick = document.getElementById('fretPick');

// chord dropdown
Object.keys(CHORDS).forEach(k=>{
  const o = document.createElement('option');
  o.value = k; o.textContent = k;
  seqChordPick.appendChild(o);
});
seqChordPick.value = "C";

function maxSteps32(){ return 32; } // storage always 32, UI shows 16/32
let chordLane = Array(maxSteps32()).fill(null); // chord name or null

// stringLanes: 6 arrays; each cell null or fret number
let stringLanes = Array.from({length:6}, ()=> Array(maxSteps32()).fill(null));

const STRING_LABELS = ["E↓","A","D","G","B","E↑"];

function buildSeqGrid(){
  const steps = getLoopSteps();
  seqGrid.style.setProperty('--nsteps', steps);
  seqGrid.innerHTML = "";

  // row CHORD
  const chordLab = document.createElement('div');
  chordLab.className = "lab";
  chordLab.textContent = "CHORD";
  seqGrid.appendChild(chordLab);

  for(let s=0;s<steps;s++){
    const d = document.createElement('div');
    d.className = "seqstep chord" + (chordLane[s] ? " on" : "");
    d.dataset.row = "chord";
    d.dataset.s = String(s);
    d.textContent = chordLane[s] ? chordLane[s] : "";
    d.addEventListener('click', ()=>{
      const pick = seqChordPick.value;
      chordLane[s] = (chordLane[s] === pick) ? null : pick;
      d.classList.toggle('on', !!chordLane[s]);
      d.textContent = chordLane[s] ? chordLane[s] : "";
    });
    seqGrid.appendChild(d);
  }

  // rows STRINGS
  for(let st=0; st<6; st++){
    const lab = document.createElement('div');
    lab.className = "lab";
    lab.textContent = `STR ${STRING_LABELS[st]}`;
    seqGrid.appendChild(lab);

    for(let s=0;s<steps;s++){
      const val = stringLanes[st][s];
      const d = document.createElement('div');
      d.className = "seqstep" + (val!==null ? " on" : "");
      d.dataset.row = "str";
      d.dataset.str = String(st);
      d.dataset.s = String(s);
      d.textContent = (val!==null) ? String(val) : "";
      d.addEventListener('click', ()=>{
        const strIdx = Number(d.dataset.str);
        const stepIdx = Number(d.dataset.s);
        const wantFret = Math.max(0, Math.min(12, Number(fretPick.value || 0)));

        // if editing specific string selected, only apply if matches OR allow click anyway
        // (più comodo: click sulla griglia = quel row)
        const current = stringLanes[strIdx][stepIdx];
        stringLanes[strIdx][stepIdx] = (current === wantFret) ? null : wantFret;

        d.classList.toggle('on', stringLanes[strIdx][stepIdx]!==null);
        d.textContent = (stringLanes[strIdx][stepIdx]!==null) ? String(stringLanes[strIdx][stepIdx]) : "";
      });
      seqGrid.appendChild(d);
    }
  }

  seqInfo.textContent = `${steps} step = loop (${Number(loopLen.value)} battuta/e)`;
}

seqClearChords.addEventListener('click', ()=>{
  chordLane.fill(null);
  buildSeqGrid();
});
seqFillChord.addEventListener('click', ()=>{
  const steps = getLoopSteps();
  for(let i=0;i<steps;i++) chordLane[i] = seqChordPick.value;
  buildSeqGrid();
});
seqClearStrings.addEventListener('click', ()=>{
  stringLanes.forEach(arr => arr.fill(null));
  buildSeqGrid();
});

seqToggle.addEventListener('click', ()=>{
  seqEnabled = !seqEnabled;
  seqToggle.textContent = seqEnabled ? "Seq: On" : "Seq: Off";
  seqStatus.textContent = seqEnabled ? "enabled" : "disabled";
  paintFlags();
});

/* =========================
   Transport (GLOBAL clock)
========================= */
const playAll = document.getElementById('playAll');
const stopAll = document.getElementById('stopAll');
const transportStatus = document.getElementById('transportStatus');
const flagsInfo = document.getElementById('flagsInfo');

let transportOn = false;
let tStep = 0;
let nextTime = 0;
let schedTimer = null;

const lookaheadMs = 25;
const scheduleAheadSec = 0.12;

function stepDurSec(){
  const bpmVal = Number(bpm.value || 120);
  return (60 / bpmVal) / 4; // 16th note duration
}

function paintFlags(){
  flagsInfo.textContent =
    `metro:${metroEnabled?'on':'off'} • drum:${drumEnabled?'on':'off'} • seq:${seqEnabled?'on':'off'}`;
}

function scheduleDrums(stepIndex, time){
  if(!drumEnabled) return;
  ensureDrumBus();

  const steps = getLoopSteps();
  if(stepIndex >= steps) return;

  // swing only on off-beat 16ths (odd steps)
  const dur = stepDurSec();
  const isOff = (stepIndex % 2) === 1;
  const swingAmt = Number(swing.value || 0);
  const t = time + (isOff ? dur * swingAmt : 0);

  drumPaintPlayhead(stepIndex);

  if(drumPattern.K[stepIndex]) kick(t);
  if(drumPattern.S[stepIndex]) snare(t);
  if(drumPattern.H[stepIndex]) hat(t);
}

function scheduleMetronome(stepIndex, time){
  if(!metroEnabled) return;
  const steps = getLoopSteps();
  const beatsPerBar = Number(sig.value || 4);
  const stepsPerBar = steps === 32 ? 16 : steps; // consider 1 bar = 16 steps, 2 bars = 32 steps
  const stepsPerBeat = Math.max(1, Math.round(stepsPerBar / beatsPerBar));

  const isBeat = (stepIndex % stepsPerBeat) === 0;
  if(!isBeat) return;

  // accent on first beat of each bar (step 0 and step 16 if 2 bars)
  const isAccent = (stepIndex === 0) || (steps === 32 && stepIndex === 16);
  clickSoundAt(time, isAccent);
}

function scheduleSeq(stepIndex, time){
  if(!seqEnabled) return;

  const steps = getLoopSteps();
  if(stepIndex >= steps) return;

  seqPaintPlayhead(stepIndex);

  // chord lane
  const ch = chordLane[stepIndex];
  if(ch){
    chordSelect.value = ch;
    renderChord(ch);
    playChordAt(time, ch);
  }

  // string lanes: collect freqs at this step, pluck in chosen strum order
  const freqs = [];
  for(let s=0; s<6; s++){
    const fret = stringLanes[s][stepIndex];
    if(fret !== null){
      freqs.push({ string: s, freq: stringFretToFreq(s, fret) });
    }
  }
  if(freqs.length){
    const ctx = ensureAudio();
    const busIn = ensureChordBus();

    let order = freqs.slice();
    const mode = strumSel.value;
    // down = low→high; up = high→low; arp = slow spread
    order.sort((a,b)=> a.string - b.string);
    if(mode === "up") order.reverse();

    const bpmVal = Number(bpm.value || 76);
    const micro = 60 / bpmVal / 8;
    const t0 = time + 0.001;

    order.forEach((it, idx)=>{
      const dt = (mode === "arp") ? idx * (micro*1.2) : idx * (micro*0.45);
      pluck(ctx, it.freq, t0 + dt, busIn, 0.16);
    });
  }
}

function scheduleStep(stepIndex, time){
  scheduleMetronome(stepIndex, time);
  scheduleDrums(stepIndex, time);
  scheduleSeq(stepIndex, time);
}

function scheduler(){
  const ctx = ensureAudio();
  const steps = getLoopSteps();

  while(nextTime < ctx.currentTime + scheduleAheadSec){
    scheduleStep(tStep, nextTime);

    // advance
    nextTime += stepDurSec();
    tStep = (tStep + 1) % steps;
  }
}

function transportStart(){
  const ctx = ensureAudio();
  if(transportOn) return;

  transportOn = true;
  playAll.disabled = true;
  stopAll.disabled = false;
  transportStatus.textContent = "playing…";
  transportStatus.className = "pill ok";

  tStep = 0;
  nextTime = ctx.currentTime + 0.06;

  schedTimer = setInterval(scheduler, lookaheadMs);
}
function transportStop(){
  if(!transportOn) return;
  transportOn = false;

  clearInterval(schedTimer);
  schedTimer = null;

  transportStatus.textContent = "stopped";
  transportStatus.className = "pill warn";

  playAll.disabled = false;
  stopAll.disabled = true;

  drumClearPlayhead();
  seqClearPlayhead();
}

playAll.addEventListener('click', transportStart);
stopAll.addEventListener('click', transportStop);

/* =========================
   Sequencer playhead paint
========================= */
function seqClearPlayhead(){
  seqGrid.querySelectorAll('.seqstep.playhead').forEach(el=>el.classList.remove('playhead'));
}
function seqPaintPlayhead(stepIndex){
  seqClearPlayhead();
  const steps = getLoopSteps();

  // Layout:
  // row0: label + steps
  // then 6 rows strings, each label + steps
  // total rows = 1 + 6 = 7
  // child index for a given row r (0..6) and step s:
  // base = r*(1+steps) + 1 + s
  for(let r=0; r<7; r++){
    const idx = r*(1+steps) + 1 + stepIndex;
    const el = seqGrid.children[idx];
    if(el) el.classList.add('playhead');
  }
}

/* =========================
   Loop length changes
========================= */
loopLen.addEventListener('change', ()=>{
  updateLoopBadges();
  buildDrumGrid();
  buildSeqGrid();

  // if transport is playing, keep playing: just wrap step with new length
  if(transportOn){
    const steps = getLoopSteps();
    tStep = tStep % steps;
  }
});

/* =========================
   Initial build
========================= */
updateLoopBadges();
buildDrumGrid();
buildSeqGrid();
paintFlags();

/* =========================
   Tuner (mic + autocorrelation)
========================= */
let micStream=null, analyser=null, micSource=null, rafId=null;
const micToggle = document.getElementById('micToggle');
const micStop = document.getElementById('micStop');
const micStatus = document.getElementById('micStatus');
const noteName = document.getElementById('noteName');
const freqRead = document.getElementById('freqRead');
const centsRead = document.getElementById('centsRead');
const targetRead = document.getElementById('targetRead');
const meterBar = document.getElementById('meterBar');

const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
function freqToNote(f){
  const A4 = 440;
  const n = 12 * Math.log2(f / A4) + 69;
  const midi = Math.round(n);
  const name = NOTE_NAMES[(midi + 1200) % 12];
  const octave = Math.floor(midi/12) - 1;
  const target = A4 * Math.pow(2, (midi-69)/12);
  const cents = Math.floor(1200 * Math.log2(f/target));
  return { midi, name, octave, target, cents };
}

function autoCorrelate(buf, sampleRate){
  const SIZE = buf.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++){ const v = buf[i]; rms += v*v; }
  rms = Math.sqrt(rms / SIZE);
  if(rms < 0.01) return null;

  let r1=0, r2=SIZE-1;
  while(r1 < SIZE/2 && Math.abs(buf[r1]) < 0.01) r1++;
  while(r2 > SIZE/2 && Math.abs(buf[r2]) < 0.01) r2--;

  const trimmed = buf.slice(r1, r2);
  const N = trimmed.length;
  const c = new Array(N).fill(0);

  for(let lag=0; lag<N; lag++){
    let sum = 0;
    for(let i=0; i<N-lag; i++){
      sum += trimmed[i] * trimmed[i+lag];
    }
    c[lag] = sum;
  }

  let d=0;
  while(d < N-1 && c[d] > c[d+1]) d++;

  let maxVal = -1, maxPos = -1;
  for(let i=d; i<N; i++){
    if(c[i] > maxVal){ maxVal = c[i]; maxPos = i; }
  }
  if(maxPos <= 0) return null;

  const x1 = c[maxPos-1] ?? 0;
  const x2 = c[maxPos];
  const x3 = c[maxPos+1] ?? 0;
  const a = (x1 + x3 - 2*x2) / 2;
  const b = (x3 - x1) / 2;
  const shift = (a ? -b/(2*a) : 0);

  const period = maxPos + shift;
  const freq = sampleRate / period;
  if(!isFinite(freq) || freq < 50 || freq > 1200) return null;
  return freq;
}

async function micOn(){
  try{
    ensureAudio();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micSource = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    micSource.connect(analyser);

    micStatus.textContent = "microfono: on";
    micToggle.disabled = true;
    micStop.disabled = false;

    const buf = new Float32Array(analyser.fftSize);
    const loop = () => {
      analyser.getFloatTimeDomainData(buf);
      const f = autoCorrelate(buf, audioCtx.sampleRate);
      if(f){
        const n = freqToNote(f);
        noteName.textContent = `${n.name}${n.octave}`;
        freqRead.textContent = `${f.toFixed(2)} Hz`;
        centsRead.textContent = `${n.cents} cents`;
        targetRead.textContent = `target: ${n.target.toFixed(2)} Hz`;

        const c = Math.max(-50, Math.min(50, n.cents));
        const pct = (c / 50) * 50;
        meterBar.style.transform = `translateX(${pct-50}%)`;
      } else {
        noteName.textContent = "—";
        freqRead.textContent = "— Hz";
        centsRead.textContent = "— cents";
        targetRead.textContent = "target: —";
        meterBar.style.transform = `translateX(-50%)`;
      }
      rafId = requestAnimationFrame(loop);
    };
    loop();
  } catch(err){
    micStatus.textContent = "microfono: errore/negato";
    console.error(err);
  }
}
function micOff(){
  if(rafId) cancelAnimationFrame(rafId);
  rafId=null;
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
  }
  micStream=null;
  analyser=null;
  micSource=null;

  micStatus.textContent = "microfono: off";
  micToggle.disabled = false;
  micStop.disabled = true;
}
micToggle.addEventListener('click', micOn);
micStop.addEventListener('click', micOff);

/* =========================
   Studio recorder (MediaRecorder)
========================= */
let recStream=null, mediaRecorder=null, chunks=[];
const recStart = document.getElementById('recStart');
const recStop = document.getElementById('recStop');
const recStatus = document.getElementById('recStatus');
const playback = document.getElementById('playback');

async function startRec(){
  try{
    recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(recStream);
    chunks = [];
    mediaRecorder.ondataavailable = (e)=> { if(e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
      playback.src = URL.createObjectURL(blob);
    };
    mediaRecorder.start();
    recStatus.textContent = "recording…";
    recStart.disabled = true;
    recStop.disabled = false;
  }catch(err){
    recStatus.textContent = "errore microfono";
    console.error(err);
  }
}
function stopRec(){
  try{ mediaRecorder && mediaRecorder.stop(); }catch(e){}
  if(recStream) recStream.getTracks().forEach(t=>t.stop());
  recStream=null;
  recStatus.textContent = "stopped";
  recStart.disabled = false;
  recStop.disabled = true;
}
recStart.addEventListener('click', startRec);
recStop.addEventListener('click', stopRec);
</script>
</body>
</html>
