<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>GuitarBand Lite — Trainer • Tuner • Studio/Loop</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#121826;
      --panel2:#0f1624;
      --txt:#e8eefc;
      --muted:#9aa7c2;
      --acc:#5eead4;
      --acc2:#60a5fa;
      --bad:#fb7185;
      --ok:#34d399;
      --bd: rgba(255,255,255,.08);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 900px at 20% 0%, #1a2440 0%, transparent 55%),
                  radial-gradient(900px 700px at 90% 10%, #12304a 0%, transparent 60%),
                  var(--bg);
      color:var(--txt);
    }
    header{
      position: sticky; top:0; z-index:10;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,15,20,.92), rgba(11,15,20,.55));
      border-bottom:1px solid var(--bd);
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
    }
    .brand{display:flex; align-items:center; gap:10px; min-width: 240px;}
    .logo{
      width:38px; height:38px; border-radius:12px;
      background: linear-gradient(135deg, rgba(94,234,212,.25), rgba(96,165,250,.18));
      border:1px solid var(--bd);
      box-shadow: var(--shadow);
      display:grid; place-items:center;
      font-weight:800; letter-spacing:.5px;
    }
    .title{line-height:1.1}
    .title b{display:block; font-size:14px}
    .title span{display:block; font-size:12px; color:var(--muted)}
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      border:1px solid var(--bd);
      background: rgba(18,24,38,.55);
      padding: 8px 12px;
      border-radius: 999px;
      color: var(--txt);
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      border-color: rgba(94,234,212,.45);
      background: rgba(94,234,212,.10);
      box-shadow: 0 0 0 3px rgba(94,234,212,.08) inset;
    }
    main{
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      .brand{min-width: unset}
    }
    .card{
      background: linear-gradient(180deg, rgba(18,24,38,.85), rgba(15,22,36,.75));
      border:1px solid var(--bd);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h2{
      margin: 0 0 10px;
      font-size: 14px;
      letter-spacing: .2px;
      color: var(--txt);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .muted{color:var(--muted); font-size:12px}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row.tight{gap:8px}
    .btn{
      border:1px solid var(--bd);
      background: rgba(255,255,255,.04);
      color: var(--txt);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      font-weight:700;
      font-size: 13px;
      letter-spacing:.2px;
    }
    .btn.primary{
      border-color: rgba(94,234,212,.45);
      background: rgba(94,234,212,.12);
    }
    .btn.blue{
      border-color: rgba(96,165,250,.45);
      background: rgba(96,165,250,.12);
    }
    .btn.danger{border-color: rgba(251,113,133,.45); background: rgba(251,113,133,.10)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    input[type="range"]{width: 180px}
    input[type="number"], select{
      background: rgba(0,0,0,.18);
      border:1px solid var(--bd);
      color: var(--txt);
      padding: 9px 10px;
      border-radius: 12px;
      outline:none;
    }
    .big{
      font-size: 44px;
      font-weight: 900;
      letter-spacing: -1px;
      margin: 8px 0 0;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .pill.ok{border-color: rgba(52,211,153,.35); color: rgba(52,211,153,.95); background: rgba(52,211,153,.06);}
    .pill.bad{border-color: rgba(251,113,133,.35); color: rgba(251,113,133,.95); background: rgba(251,113,133,.06);}
    .meter{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--bd);
      overflow:hidden;
    }
    .meter > i{
      display:block;
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(251,113,133,.9), rgba(94,234,212,.9), rgba(251,113,133,.9));
      transform: translateX(-50%);
      will-change: transform;
    }
    .chordBox{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items:start;
    }
    @media (max-width: 640px){ .chordBox{grid-template-columns:1fr} }
    .fret{
      width: 100%;
      max-width: 340px;
      border-radius: 14px;
      border:1px solid var(--bd);
      background: rgba(0,0,0,.18);
      padding: 10px;
    }
    canvas{width:100%; height:auto; display:block}
    .hint{
      font-size: 12px;
      color: var(--muted);
      margin-top:8px;
      line-height:1.35;
    }
    audio{width:100%}
    .hide{display:none}

    /* Drum grid */
    .steps{
      display:grid;
      grid-template-columns: 42px repeat(16, 1fr);
      gap: 6px;
      align-items:center;
      margin-top: 10px;
    }
    .steps.step32{ grid-template-columns: 42px repeat(32, 1fr); }
    .steps .lab{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      padding-right:6px;
      user-select:none;
    }
    .step{
      height: 20px;
      border-radius: 8px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      position:relative;
    }
    .step.on{
      border-color: rgba(96,165,250,.45);
      background: rgba(96,165,250,.16);
      box-shadow: 0 0 0 3px rgba(96,165,250,.06) inset;
    }
    .step.playhead::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 10px;
      border:2px solid rgba(94,234,212,.55);
      pointer-events:none;
    }

    /* Sequencer grid */
    .seqsteps{
      display:grid;
      grid-template-columns: 86px repeat(16, 1fr);
      gap: 6px;
      align-items:center;
      margin-top: 10px;
    }
    .seqsteps.step32{ grid-template-columns: 86px repeat(32, 1fr); }
    .seqsteps .lab{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
      padding-right:6px;
      user-select:none;
      white-space: nowrap;
    }
    .seqstep{
      height: 24px;
      border-radius: 9px;
      border:1px solid var(--bd);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      position:relative;
      display:grid;
      place-items:center;
      font-size: 11px;
      color: rgba(232,238,252,.92);
      user-select:none;
      overflow:hidden;
    }
    .seqstep.on{
      border-color: rgba(94,234,212,.50);
      background: rgba(94,234,212,.12);
      box-shadow: 0 0 0 3px rgba(94,234,212,.06) inset;
    }
    .seqstep.playhead::after{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 11px;
      border:2px solid rgba(96,165,250,.55);
      pointer-events:none;
    }

    .hr{border:none;border-top:1px solid var(--bd);margin:14px 0}
  </style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo">GB</div>
    <div class="title">
      <b>GuitarBand Lite</b>
      <span>metronomo • accordi • tuner • studio/loop</span>
    </div>
  </div>
  <div class="tabs">
    <div class="tab active" data-view="practice">Practice</div>
    <div class="tab" data-view="tuner">Tuner</div>
    <div class="tab" data-view="studio">Studio</div>
  </div>
</header>

<main>
  <!-- PRACTICE -->
  <section id="view-practice" class="grid">
    <div class="card">
      <h2>
        Trainer accordi
        <span class="pill" id="trainerStatus">pronto</span>
      </h2>

      <div class="chordBox">
        <div>
          <div class="row">
            <label class="muted">Accordo</label>
            <select id="chordSelect"></select>
            <button class="btn" id="nextChord">Prossimo</button>

            <button class="btn primary" id="playChord">Play</button>
            <select id="strum">
              <option value="down">↓ down</option>
              <option value="up">↑ up</option>
              <option value="arp">arp</option>
            </select>
          </div>
          <div class="big" id="chordName">—</div>
          <div class="hint" id="chordHint">Seleziona un accordo e prova a suonarlo a tempo.</div>
        </div>

        <div class="fret">
          <canvas id="fretCanvas" width="520" height="340"></canvas>
          <div class="hint">Diagramma semplice (capotasto in alto). “X” = corda muta, “0” = corda a vuoto.</div>
        </div>
      </div>

      <hr class="hr">

      <div class="row">
        <button class="btn primary" id="startTrainer">Avvia sessione</button>
        <button class="btn" id="stopTrainer" disabled>Stop</button>

        <label class="muted">Cambio ogni</label>
        <input type="number" id="changeEvery" value="20" min="5" max="120" style="width:90px">
        <span class="muted">sec</span>

        <label class="muted">Set</label>
        <select id="chordSet">
          <option value="basic">Base (Em Am C G D)</option>
          <option value="open">Open (E A D G C F Am Em Dm)</option>
          <option value="all">Tutti</option>
        </select>
      </div>
    </div>

    <div class="card">
      <h2>Metronomo / Groove</h2>
      <div class="row">
        <button class="btn primary" id="metroToggle">Metronomo: Off</button>
        <label class="muted">BPM</label>
        <input type="range" id="bpm" min="40" max="220" value="76">
        <input type="number" id="bpmNum" min="40" max="220" value="76" style="width:90px">
        <label class="muted">Time</label>
        <select id="sig">
          <option value="4">4/4</option>
          <option value="3">3/4</option>
          <option value="6">6/8</option>
        </select>
      </div>
      <div class="hint" id="metroHint">Ora il click è schedulato sul clock audio (sincronizzabile con Drum/Sequencer).</div>

      <hr class="hr">

      <h2>Drone (tonica)</h2>
      <div class="row">
        <select id="droneNote">
          <option value="110">A2 (110 Hz)</option>
          <option value="146.83">D3 (146.83 Hz)</option>
          <option value="196">G3 (196 Hz)</option>
          <option value="261.63">C4 (261.63 Hz)</option>
          <option value="329.63">E4 (329.63 Hz)</option>
        </select>
        <button class="btn" id="droneToggle">On/Off</button>
        <label class="muted">Volume</label>
        <input type="range" id="droneVol" min="0" max="1" step="0.01" value="0.18">
      </div>
      <div class="hint">Il drone aiuta l’orecchio: suona scale/accordi sopra una nota fissa.</div>

      <hr class="hr">

      <h2>Drum machine (16/32 step)</h2>
      <div class="row">
        <button class="btn blue" id="drumToggle">Drum: Off</button>
        <label class="muted">Swing</label>
        <input type="range" id="swing" min="0" max="0.6" step="0.01" value="0.10">
        <label class="muted">Vol</label>
        <input type="range" id="drumVol" min="0" max="1" step="0.01" value="0.65">
        <span class="pill" id="drumLenPill">16 step</span>
      </div>
      <div class="hint">Griglia step: clicca per attivare. Segue il BPM e può partire anche dal Transport in Studio.</div>

      <div class="steps" id="stepGrid"></div>
    </div>
  </section>

  <!-- TUNER -->
  <section id="view-tuner" class="grid hide">
    <div class="card">
      <h2>
        Tuner (microfono)
        <span class="pill" id="micStatus">microfono: off</span>
      </h2>
      <div class="row">
        <button class="btn primary" id="micToggle">Attiva microfono</button>
        <button class="btn" id="micStop" disabled>Disattiva</button>
        <span class="muted">Suggerimento: pizzica una corda singola, niente accordo.</span>
      </div>

      <div style="margin-top:10px">
        <div class="muted">Nota rilevata</div>
        <div class="big" id="noteName">—</div>
        <div class="row">
          <span class="pill" id="freqRead">— Hz</span>
          <span class="pill" id="centsRead">— cents</span>
          <span class="pill" id="targetRead">target: —</span>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Intonazione</div>
          <div class="meter"><i id="meterBar"></i></div>
          <div class="hint">Al centro = in tono. A sinistra = basso, a destra = alto.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Accordatura standard (chitarra)</h2>
      <div class="row" style="gap:8px">
        <span class="pill">E2 82.41</span>
        <span class="pill">A2 110.00</span>
        <span class="pill">D3 146.83</span>
        <span class="pill">G3 196.00</span>
        <span class="pill">B3 246.94</span>
        <span class="pill">E4 329.63</span>
      </div>
      <div class="hint">Per iniziare: accorda E2 e A2 con calma: sono le più “sensibili” al rumore.</div>
    </div>
  </section>

  <!-- STUDIO -->
  <section id="view-studio" class="grid hide">
    <div class="card">
      <h2>
        Transport (tutto sincronizzato)
        <span class="pill" id="transportStatus">stopped</span>
      </h2>

      <div class="row">
        <button class="btn primary" id="playAll">PLAY ALL</button>
        <button class="btn" id="stopAll" disabled>STOP</button>

        <label class="muted">Loop</label>
        <select id="loopLen">
          <option value="16">1 battuta (16 step)</option>
          <option value="32">2 battute (32 step)</option>
        </select>

        <span class="pill" id="transportFlags">metro:off • drum:off • seq:off</span>
      </div>

      <div class="row tight" style="margin-top:8px">
        <button class="btn" id="toggleMetroInTransport">Metronomo: Off</button>
        <button class="btn" id="toggleDrumInTransport">Drum: Off</button>
        <button class="btn" id="toggleSeqInTransport">Seq: Off</button>
        <span class="pill">Strum: <b id="strumEcho">↓ down</b></span>
      </div>

      <div class="hint">Un solo clock audio pilota: metronomo, drum, accordi e corde (sequencer). Microfono/rec è separato.</div>

      <hr class="hr">

      <h2>Sequencer — Accordi + 6 corde (step quantizzati)</h2>

      <div class="row">
        <label class="muted">Accordo</label>
        <select id="seqChordPick"></select>
        <button class="btn" id="seqClearChords">Clear chords</button>
        <button class="btn" id="seqFillChord">Fill loop</button>

        <span class="pill" id="seqInfo">16 step = 1 battuta (4/4)</span>
      </div>

      <div class="row" style="margin-top:6px">
        <label class="muted">Edit corde</label>
        <select id="seqStringPick">
          <option value="0">E (bassa)</option>
          <option value="1">A</option>
          <option value="2">D</option>
          <option value="3">G</option>
          <option value="4">B</option>
          <option value="5">E (alta)</option>
        </select>
        <label class="muted">Fret</label>
        <input type="number" id="seqFretPick" min="0" max="12" value="0" style="width:90px">
        <button class="btn" id="seqClearStrings">Clear corde</button>
        <span class="pill">Click step = toggle (mette il fret selezionato)</span>
      </div>

      <div class="seqsteps" id="seqGrid"></div>

      <div class="row" style="margin-top:12px">
        <button class="btn blue" id="seqLocalToggle">Seq: Off</button>
        <span class="pill" id="seqStatus">idle</span>
      </div>

      <div class="hint">
        Riga CHORD: clic per assegnare l’accordo selezionato.<br>
        Righe corde: scegli corda + fret, poi clic sugli step per inserire/togliere la nota su quella corda.
      </div>
    </div>

    <div class="card">
      <h2>Studio (registrazione rapida)</h2>
      <div class="row">
        <button class="btn primary" id="recStart">Rec</button>
        <button class="btn danger" id="recStop" disabled>Stop</button>
        <span class="pill" id="recStatus">idle</span>
      </div>
      <div class="hint">Registra dal microfono (MediaRecorder → webm/ogg). Registrare il mix interno richiede MediaStreamDestination (aggiungibile).</div>

      <div style="margin-top:12px">
        <audio id="playback" controls></audio>
      </div>

      <hr class="hr">

      <h2>Roadmap “GarageBand style”</h2>
      <ul class="muted" style="margin:0; padding-left: 18px; line-height:1.6">
        <li>Looper 1–2 battute con quantizzazione</li>
        <li>Registrazione del mix interno (WebAudio → MediaStreamDestination)</li>
        <li>Effetti: EQ + reverb + delay</li>
        <li>Multi-track con mute/solo e mix volumi</li>
      </ul>
    </div>
  </section>
</main>

<script>
/* =========================================================
   AUDIO CORE
========================================================= */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}

/* =========================================================
   UI: Tabs / Views
========================================================= */
const tabs = [...document.querySelectorAll('.tab')];
const views = {
  practice: document.getElementById('view-practice'),
  tuner: document.getElementById('view-tuner'),
  studio: document.getElementById('view-studio'),
};
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  const v = t.dataset.view;
  Object.entries(views).forEach(([k, el]) => el.classList.toggle('hide', k !== v));
}));

/* =========================================================
   GLOBAL BPM / SIGNATURE
========================================================= */
const bpm = document.getElementById('bpm');
const bpmNum = document.getElementById('bpmNum');
const sig = document.getElementById('sig');

bpm.addEventListener('input', () => bpmNum.value = bpm.value);
bpmNum.addEventListener('input', () => bpm.value = bpmNum.value);

function beatsPerBar(){
  const v = Number(sig.value);
  // 6/8 lo trattiamo come 6 beat (semplificato)
  return v;
}
function stepDurSec(){
  // 16th note
  const bpmVal = Number(bpm.value || 120);
  return (60 / bpmVal) / 4;
}

/* =========================================================
   CHORDS + DIAGRAM
========================================================= */
const CHORDS = {
  "Em": { fingering: ["0","2","2","0","0","0"], hint:"Em: classico, facile. Suona tutte le corde." },
  "Am": { fingering: ["X","0","2","2","1","0"], hint:"Am: attenzione a non stoppare la 1ª corda." },
  "C":  { fingering: ["X","3","2","0","1","0"], hint:"C: polso rilassato, dita arcuate." },
  "G":  { fingering: ["3","2","0","0","0","3"], hint:"G: prova anche variante con 2 dita su B e high E." },
  "D":  { fingering: ["X","X","0","2","3","2"], hint:"D: suona solo le ultime 4 corde." },
  "E":  { fingering: ["0","2","2","1","0","0"], hint:"E: come Em ma aggiungi il 1° dito al 1° tasto della 3ª corda." },
  "A":  { fingering: ["X","0","2","2","2","0"], hint:"A: prova a usare 3 dita o un mini barrè." },
  "Dm": { fingering: ["X","X","0","2","3","1"], hint:"Dm: punta delle dita, non schiacciare troppo." },
  "F":  { fingering: ["1","3","3","2","1","1"], hint:"F: barrè completo (difficile). Inizia con mini-barrè sulle prime 2 corde." },
};

const chordSelect = document.getElementById('chordSelect');
const chordName = document.getElementById('chordName');
const chordHint = document.getElementById('chordHint');
const nextChord = document.getElementById('nextChord');
const fretCanvas = document.getElementById('fretCanvas');
const ctx2d = fretCanvas.getContext('2d');

const chordSet = document.getElementById('chordSet');
function getSet(){
  const all = Object.keys(CHORDS);
  if(chordSet.value==="basic") return ["Em","Am","C","G","D"];
  if(chordSet.value==="open") return ["E","A","D","G","C","F","Am","Em","Dm"];
  return all;
}
function setOptions(list){
  chordSelect.innerHTML = "";
  list.forEach(k=>{
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k;
    chordSelect.appendChild(opt);
  });
}
setOptions(getSet());

chordSet.addEventListener('change', ()=>{
  const list = getSet();
  setOptions(list);
  chordSelect.value = list[0];
  renderChord(list[0]);
});

function drawFret(f){
  const W = fretCanvas.width, H = fretCanvas.height;
  ctx2d.clearRect(0,0,W,H);
  ctx2d.fillStyle = "rgba(0,0,0,.18)";
  ctx2d.fillRect(0,0,W,H);

  const pad = 46;
  const left = pad, top = pad;
  const right = W - pad, bottom = H - pad;
  const strings = 6, frets = 5;

  ctx2d.strokeStyle = "rgba(255,255,255,.25)";
  ctx2d.lineWidth = 3;
  for(let i=0;i<strings;i++){
    const x = left + (right-left) * (i/(strings-1));
    ctx2d.beginPath();
    ctx2d.moveTo(x, top);
    ctx2d.lineTo(x, bottom);
    ctx2d.stroke();
  }

  for(let j=0;j<=frets;j++){
    const y = top + (bottom-top) * (j/frets);
    ctx2d.strokeStyle = (j===0) ? "rgba(255,255,255,.50)" : "rgba(255,255,255,.20)";
    ctx2d.lineWidth = (j===0) ? 10 : 3;
    ctx2d.beginPath();
    ctx2d.moveTo(left, y);
    ctx2d.lineTo(right, y);
    ctx2d.stroke();
  }

  ctx2d.font = "bold 24px ui-sans-serif, system-ui";
  ctx2d.textAlign = "center";
  ctx2d.textBaseline = "middle";

  for(let i=0;i<6;i++){
    const x = left + (right-left) * (i/5);
    const v = f[i];
    if(v==="X" || v==="0"){
      ctx2d.fillStyle = "rgba(255,255,255,.85)";
      ctx2d.fillText(v, x, top - 22);
    } else {
      const fretNum = Number(v);
      const y = top + (bottom-top) * ((fretNum-0.5)/frets);
      ctx2d.fillStyle = "rgba(94,234,212,.95)";
      ctx2d.beginPath();
      ctx2d.arc(x, y, 18, 0, Math.PI*2);
      ctx2d.fill();
      ctx2d.fillStyle = "rgba(0,0,0,.75)";
      ctx2d.fillText(String(fretNum), x, y+1);
    }
  }
}

function renderChord(name){
  const c = CHORDS[name];
  chordName.textContent = name;
  chordHint.textContent = c?.hint ?? "";
  drawFret(c?.fingering ?? ["X","X","X","X","X","X"]);
}

chordSelect.addEventListener('change', ()=> renderChord(chordSelect.value));
nextChord.addEventListener('click', ()=>{
  const list = getSet();
  const idx = list.indexOf(chordSelect.value);
  const next = list[(idx+1) % list.length];
  chordSelect.value = next;
  renderChord(next);
});

// init
chordSelect.value = getSet()[0];
renderChord(chordSelect.value);

/* =========================================================
   GUITAR SYNTH (strings + chords + arpeggio)
========================================================= */
const playChordBtn = document.getElementById('playChord');
const strumSel = document.getElementById('strum');
const strumEcho = document.getElementById('strumEcho');
strumSel.addEventListener('change', ()=> {
  const map = {down:"↓ down", up:"↑ up", arp:"arp"};
  strumEcho.textContent = map[strumSel.value] || strumSel.value;
});

// Standard tuning frequencies lowE..highE
const TUNING = [82.41, 110.00, 146.83, 196.00, 246.94, 329.63];
const SEMI = Math.pow(2, 1/12);

function stringFretToFreq(stringIndex, fret){
  return TUNING[stringIndex] * Math.pow(SEMI, fret);
}
function chordToFreqs(fingering){
  const freqs = [];
  for(let i=0;i<6;i++){
    const v = fingering[i];
    if(v === "X") continue;
    const fret = Number(v);
    freqs.push(stringFretToFreq(i, fret));
  }
  return freqs;
}

let guitarBusIn = null;
function ensureGuitarBus(){
  const ctx = ensureAudio();
  if(guitarBusIn) return guitarBusIn;

  const comp = ctx.createDynamicsCompressor();
  comp.threshold.value = -18;
  comp.knee.value = 18;
  comp.ratio.value = 3.5;
  comp.attack.value = 0.005;
  comp.release.value = 0.12;

  const out = ctx.createGain();
  out.gain.value = 0.95;

  comp.connect(out).connect(ctx.destination);
  guitarBusIn = comp;
  return guitarBusIn;
}

function pluckAt(ctx, freq, t, out, amp=0.18){
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  const f = ctx.createBiquadFilter();

  o.type = 'triangle';
  o.frequency.setValueAtTime(freq, t);
  o.detune.setValueAtTime((Math.random()*6-3), t);

  f.type = 'lowpass';
  f.frequency.setValueAtTime(2200, t);
  f.Q.setValueAtTime(0.8, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(amp, t + 0.008);
  g.gain.exponentialRampToValueAtTime(amp*0.35, t + 0.10);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.55);

  o.connect(f).connect(g).connect(out);
  o.start(t);
  o.stop(t + 0.6);
}

function playChordAt(time, chordNameToPlay){
  const ctx = ensureAudio();
  const out = ensureGuitarBus();
  const fingering = CHORDS[chordNameToPlay]?.fingering;
  if(!fingering) return;

  const freqs = chordToFreqs(fingering);
  const mode = strumSel.value;

  const bpmVal = Number(bpm.value || 76);
  const step = 60 / bpmVal / 8; // micro-offset per strum/arp

  let order = freqs.slice();
  if(mode === "up") order = order.reverse();

  order.forEach((fq, idx)=>{
    const dt = (mode === "arp") ? idx * (step*1.2) : idx * (step*0.5);
    pluckAt(ctx, fq, time + dt, out, 0.18);
  });
}

function playStringAt(time, stringIndex, fret){
  const ctx = ensureAudio();
  const out = ensureGuitarBus();
  const fq = stringFretToFreq(stringIndex, fret);
  pluckAt(ctx, fq, time, out, 0.16);
}

function playChordNow(){
  const ctx = ensureAudio();
  const t0 = ctx.currentTime + 0.03;
  playChordAt(t0, chordSelect.value);
}
playChordBtn.addEventListener('click', playChordNow);

/* =========================================================
   TRAINER (auto-change chord)
========================================================= */
let trainerTimer = null;
const startTrainer = document.getElementById('startTrainer');
const stopTrainer = document.getElementById('stopTrainer');
const changeEvery = document.getElementById('changeEvery');
const trainerStatus = document.getElementById('trainerStatus');

function trainerStart(){
  if(trainerTimer) return;
  trainerStatus.textContent = "in sessione";
  startTrainer.disabled = true;
  stopTrainer.disabled = false;

  const list = getSet();
  const step = () => {
    const rnd = list[Math.floor(Math.random()*list.length)];
    chordSelect.value = rnd;
    renderChord(rnd);
  };
  step();
  trainerTimer = setInterval(step, Number(changeEvery.value)*1000);
}
function trainerStop(){
  clearInterval(trainerTimer);
  trainerTimer = null;
  trainerStatus.textContent = "pronto";
  startTrainer.disabled = false;
  stopTrainer.disabled = true;
}
startTrainer.addEventListener('click', trainerStart);
stopTrainer.addEventListener('click', trainerStop);

/* =========================================================
   DRONE (tonic)
========================================================= */
let droneOsc=null, droneGain=null;
const droneToggle = document.getElementById('droneToggle');
const droneNote = document.getElementById('droneNote');
const droneVol = document.getElementById('droneVol');

function droneOn(){
  const ctx = ensureAudio();
  droneOsc = ctx.createOscillator();
  droneGain = ctx.createGain();
  droneOsc.type = 'sine';
  droneOsc.frequency.value = Number(droneNote.value);
  droneGain.gain.value = Number(droneVol.value);
  droneOsc.connect(droneGain).connect(ctx.destination);
  droneOsc.start();
}
function droneOff(){
  try{ droneOsc && droneOsc.stop(); }catch(e){}
  droneOsc=null;
  droneGain=null;
}
droneToggle.addEventListener('click', ()=>{
  if(droneOsc){ droneOff(); }
  else { droneOn(); }
});
droneNote.addEventListener('change', ()=>{
  if(droneOsc){ droneOsc.frequency.value = Number(droneNote.value); }
});
droneVol.addEventListener('input', ()=>{
  if(droneGain){ droneGain.gain.value = Number(droneVol.value); }
});

/* =========================================================
   DRUM SYNTH + PATTERN (16/32 step)
========================================================= */
const drumToggle = document.getElementById('drumToggle');
const swing = document.getElementById('swing');
const drumVol = document.getElementById('drumVol');
const stepGrid = document.getElementById('stepGrid');
const drumLenPill = document.getElementById('drumLenPill');

const tracks = ["K","S","H"]; // kick, snare, hat
let LOOP_STEPS = 16;

let pattern = {
  K: Array(16).fill(false),
  S: Array(16).fill(false),
  H: Array(16).fill(false),
};

// default groove helper
function fillDefaultGroove(){
  pattern.K.fill(false); pattern.S.fill(false); pattern.H.fill(false);
  const steps = pattern.K.length;
  // kick on beats
  for(let i=0;i<steps;i+=4) pattern.K[i] = true;
  // snare on 2 and 4 (in 16-step: 4 & 12; in 32: 4,12,20,28)
  if(steps === 16){
    [4,12].forEach(i=>pattern.S[i]=true);
    [2,6,10,14].forEach(i=>pattern.H[i]=true);
  } else {
    [4,12,20,28].forEach(i=>pattern.S[i]=true);
    for(let i=2;i<steps;i+=4) pattern.H[i]=true;
  }
}
fillDefaultGroove();

let drumMaster = null;
function ensureDrumBus(){
  const ctx = ensureAudio();
  if(drumMaster) return drumMaster;
  drumMaster = ctx.createGain();
  drumMaster.gain.value = Number(drumVol.value || 0.65);
  drumMaster.connect(ctx.destination);
  return drumMaster;
}
drumVol.addEventListener('input', ()=>{ if(drumMaster) drumMaster.gain.value = Number(drumVol.value); });

function kick(t){
  const ctx = ensureAudio();
  const out = ensureDrumBus();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(150, t);
  o.frequency.exponentialRampToValueAtTime(55, t + 0.08);
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.9, t + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
  o.connect(g).connect(out);
  o.start(t);
  o.stop(t + 0.14);
}
function snare(t){
  const ctx = ensureAudio();
  const out = ensureDrumBus();
  const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

  const noise = ctx.createBufferSource();
  noise.buffer = noiseBuf;

  const hp = ctx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 1200;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.35, t + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.11);

  noise.connect(hp).connect(g).connect(out);
  noise.start(t);
  noise.stop(t + 0.12);

  const o = ctx.createOscillator();
  const og = ctx.createGain();
  o.type = 'triangle';
  o.frequency.setValueAtTime(210, t);
  og.gain.setValueAtTime(0.0001, t);
  og.gain.exponentialRampToValueAtTime(0.10, t + 0.004);
  og.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
  o.connect(og).connect(out);
  o.start(t);
  o.stop(t + 0.1);
}
function hat(t){
  const ctx = ensureAudio();
  const out = ensureDrumBus();
  const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);

  const src = ctx.createBufferSource();
  src.buffer = noiseBuf;

  const bp = ctx.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 9000;
  bp.Q.value = 0.8;

  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.22, t + 0.002);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);

  src.connect(bp).connect(g).connect(out);
  src.start(t);
  src.stop(t + 0.06);
}

/* =========================================================
   SEQUENCER DATA (chords + 6 strings), 16/32 step
========================================================= */
const seqChordPick = document.getElementById('seqChordPick');
const seqClearChords = document.getElementById('seqClearChords');
const seqFillChord = document.getElementById('seqFillChord');
const seqClearStrings = document.getElementById('seqClearStrings');
const seqGrid = document.getElementById('seqGrid');
const seqStatus = document.getElementById('seqStatus');
const seqInfo = document.getElementById('seqInfo');
const seqStringPick = document.getElementById('seqStringPick');
const seqFretPick = document.getElementById('seqFretPick');
const seqLocalToggle = document.getElementById('seqLocalToggle');

Object.keys(CHORDS).forEach(k=>{
  const o = document.createElement('option');
  o.value = k; o.textContent = k;
  seqChordPick.appendChild(o);
});
seqChordPick.value = "C";

let chordLane = Array(16).fill(null); // chord name or null
let stringLanes = Array.from({length:6}, ()=> Array(16).fill(null)); // fret number or null

function resizeSequencer(steps){
  chordLane = Array(steps).fill(null);
  stringLanes = Array.from({length:6}, ()=> Array(steps).fill(null));
  buildSeqGrid();
}

function buildSeqGrid(){
  seqGrid.innerHTML = "";
  seqGrid.classList.toggle('step32', LOOP_STEPS === 32);

  // CHORD row
  const chordLab = document.createElement('div');
  chordLab.className = "lab";
  chordLab.textContent = "CHORD";
  seqGrid.appendChild(chordLab);

  for(let s=0;s<LOOP_STEPS;s++){
    const d = document.createElement('div');
    d.className = "seqstep" + (chordLane[s] ? " on" : "");
    d.dataset.row = "chord";
    d.dataset.s = String(s);
    d.textContent = chordLane[s] ? chordLane[s] : "";
    d.addEventListener('click', ()=>{
      const pick = seqChordPick.value;
      chordLane[s] = (chordLane[s] === pick) ? null : pick;
      d.classList.toggle('on', !!chordLane[s]);
      d.textContent = chordLane[s] ? chordLane[s] : "";
    });
    seqGrid.appendChild(d);
  }

  const labels = ["STR E↓","STR A","STR D","STR G","STR B","STR E↑"];
  for(let r=0;r<6;r++){
    const lab = document.createElement('div');
    lab.className = "lab";
    lab.textContent = labels[r];
    seqGrid.appendChild(lab);

    for(let s=0;s<LOOP_STEPS;s++){
      const val = stringLanes[r][s];
      const d = document.createElement('div');
      d.className = "seqstep" + (val!==null ? " on" : "");
      d.dataset.row = String(r);
      d.dataset.s = String(s);
      d.textContent = (val!==null) ? String(val) : "";
      d.addEventListener('click', ()=>{
        const targetString = Number(seqStringPick.value);
        const fret = Math.max(0, Math.min(12, Number(seqFretPick.value || 0)));
        // se clicchi una riga diversa dalla corda selezionata: aggiorna selezione corda
        if(targetString !== r){
          seqStringPick.value = String(r);
        }
        const cur = stringLanes[r][s];
        if(cur === fret){
          stringLanes[r][s] = null;
          d.classList.remove('on');
          d.textContent = "";
        } else {
          stringLanes[r][s] = fret;
          d.classList.add('on');
          d.textContent = String(fret);
        }
      });
      seqGrid.appendChild(d);
    }
  }
}
buildSeqGrid();

/* =========================================================
   METRONOME CLICK (scheduled)
========================================================= */
let metroEnabled = false;   // can be used by transport and/or practice
const metroToggle = document.getElementById('metroToggle');
const metroHint = document.getElementById('metroHint');

function clickSoundAt(t, isAccent){
  const ctx = ensureAudio();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = 'square';
  o.frequency.value = isAccent ? 1400 : 980;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(isAccent ? 0.25 : 0.15, t + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);
  o.connect(g).connect(ctx.destination);
  o.start(t);
  o.stop(t + 0.07);
}

function setMetroEnabled(on){
  metroEnabled = !!on;
  metroToggle.textContent = `Metronomo: ${metroEnabled ? 'On' : 'Off'}`;
  document.getElementById('toggleMetroInTransport').textContent = `Metronomo: ${metroEnabled ? 'On' : 'Off'}`;
  updateTransportFlags();
}
metroToggle.addEventListener('click', ()=>{
  ensureAudio();
  setMetroEnabled(!metroEnabled);
});

/* =========================================================
   DRUM enable toggle (Practice + Transport)
========================================================= */
let drumEnabled = false;
function setDrumEnabled(on){
  drumEnabled = !!on;
  drumToggle.textContent = `Drum: ${drumEnabled ? 'On' : 'Off'}`;
  document.getElementById('toggleDrumInTransport').textContent = `Drum: ${drumEnabled ? 'On' : 'Off'}`;
  updateTransportFlags();
}
drumToggle.addEventListener('click', ()=>{
  ensureAudio();
  setDrumEnabled(!drumEnabled);
});

/* =========================================================
   SEQ enable toggle (Studio local + Transport)
========================================================= */
let seqEnabled = false;
function setSeqEnabled(on){
  seqEnabled = !!on;
  seqLocalToggle.textContent = `Seq: ${seqEnabled ? 'On' : 'Off'}`;
  document.getElementById('toggleSeqInTransport').textContent = `Seq: ${seqEnabled ? 'On' : 'Off'}`;
  updateTransportFlags();
}
seqLocalToggle.addEventListener('click', ()=>{
  ensureAudio();
  setSeqEnabled(!seqEnabled);
});

/* =========================================================
   Loop length (16/32) affects Drum+Seq grids/data
========================================================= */
const loopLen = document.getElementById('loopLen');
loopLen.addEventListener('change', ()=>{
  const steps = Number(loopLen.value);
  setLoopSteps(steps);
});

function setLoopSteps(steps){
  LOOP_STEPS = (steps === 32) ? 32 : 16;

  // resize drum patterns
  pattern = {
    K: Array(LOOP_STEPS).fill(false),
    S: Array(LOOP_STEPS).fill(false),
    H: Array(LOOP_STEPS).fill(false),
  };
  fillDefaultGroove();
  buildDrumGrid();

  // resize sequencer
  resizeSequencer(LOOP_STEPS);

  // update pills
  drumLenPill.textContent = `${LOOP_STEPS} step`;
  seqInfo.textContent = (LOOP_STEPS === 16) ? `16 step = 1 battuta (4/4)` : `32 step = loop 2 battute`;
  updateTransportFlags();
}

// init loop
setLoopSteps(16);

/* =========================================================
   Drum grid UI build + playhead
========================================================= */
function buildDrumGrid(){
  stepGrid.innerHTML = "";
  stepGrid.classList.toggle('step32', LOOP_STEPS === 32);

  tracks.forEach(tr=>{
    const lab = document.createElement('div');
    lab.className = "lab";
    lab.textContent = tr;
    stepGrid.appendChild(lab);

    for(let i=0;i<LOOP_STEPS;i++){
      const d = document.createElement('div');
      d.className = "step" + (pattern[tr][i] ? " on" : "");
      d.dataset.tr = tr;
      d.dataset.i = String(i);
      d.addEventListener('click', ()=>{
        const t = d.dataset.tr;
        const idx = Number(d.dataset.i);
        pattern[t][idx] = !pattern[t][idx];
        d.classList.toggle('on', pattern[t][idx]);
      });
      stepGrid.appendChild(d);
    }
  });
}
function drumClearPlayhead(){
  stepGrid.querySelectorAll('.step.playhead').forEach(el=>el.classList.remove('playhead'));
}
function drumPaintPlayhead(stepIndex){
  drumClearPlayhead();
  tracks.forEach((tr, row)=>{
    const perRow = 1 + LOOP_STEPS;
    const flatIndex = row * perRow + 1 + stepIndex;
    const el = stepGrid.children[flatIndex];
    if(el) el.classList.add('playhead');
  });
}

/* =========================================================
   Sequencer playhead
========================================================= */
function seqClearPlayhead(){
  seqGrid.querySelectorAll('.seqstep.playhead').forEach(el=>el.classList.remove('playhead'));
}
function seqPaintPlayhead(stepIndex){
  seqClearPlayhead();
  const cols = 1 + LOOP_STEPS;
  // chord row starts after label
  const chordIndex = 1 + stepIndex;
  const a = seqGrid.children[chordIndex];
  if(a) a.classList.add('playhead');

  // 6 string rows follow: each row has label + LOOP_STEPS cells
  for(let r=0;r<6;r++){
    const base = cols /* chord row */ + r*cols;
    const idx = base + 1 + stepIndex;
    const el = seqGrid.children[idx];
    if(el) el.classList.add('playhead');
  }
}

/* =========================================================
   Transport: one scheduler for metro + drum + seq
========================================================= */
const playAll = document.getElementById('playAll');
const stopAll = document.getElementById('stopAll');
const transportStatus = document.getElementById('transportStatus');
const transportFlags = document.getElementById('transportFlags');
const toggleMetroInTransport = document.getElementById('toggleMetroInTransport');
const toggleDrumInTransport = document.getElementById('toggleDrumInTransport');
const toggleSeqInTransport  = document.getElementById('toggleSeqInTransport');

function updateTransportFlags(){
  transportFlags.textContent = `metro:${metroEnabled?'on':'off'} • drum:${drumEnabled?'on':'off'} • seq:${seqEnabled?'on':'off'} • ${LOOP_STEPS} step`;
}
updateTransportFlags();

toggleMetroInTransport.addEventListener('click', ()=>{ ensureAudio(); setMetroEnabled(!metroEnabled); });
toggleDrumInTransport.addEventListener('click', ()=>{ ensureAudio(); setDrumEnabled(!drumEnabled); });
toggleSeqInTransport.addEventListener('click',  ()=>{ ensureAudio(); setSeqEnabled(!seqEnabled); });

let transportOn = false;
let transportStep = 0;
let nextNoteTime = 0;
let schedulerTimer = null;
const LOOKAHEAD_MS = 25;
const SCHEDULE_AHEAD_SEC = 0.14;
let metroBeatCount = 0;

function scheduleTransportStep(stepIndex, time){
  // playheads
  if(drumEnabled) drumPaintPlayhead(stepIndex);
  if(seqEnabled)  seqPaintPlayhead(stepIndex);

  // metronome: tick on each 1/4 note -> stepIndex % 4 == 0
  if(metroEnabled && (stepIndex % 4 === 0)){
    const beatInBar = metroBeatCount % beatsPerBar();
    const isAccent = (beatInBar === 0);
    clickSoundAt(time, isAccent);
    metroBeatCount++;
  }

  // drum
  if(drumEnabled){
    if(pattern.K[stepIndex]) kick(time);
    if(pattern.S[stepIndex]) snare(time);
    if(pattern.H[stepIndex]) hat(time);
  }

  // sequencer: chords + strings
  if(seqEnabled){
    const ch = chordLane[stepIndex];
    if(ch){
      // aggiorna UI ma suona schedulato
      chordSelect.value = ch;
      renderChord(ch);
      playChordAt(time + 0.01, ch);
    }
    // per ogni corda, se c'è un fret -> suona quella corda
    for(let s=0;s<6;s++){
      const fret = stringLanes[s][stepIndex];
      if(fret !== null){
        playStringAt(time + 0.01, s, fret);
      }
    }
  }
}

function transportScheduler(){
  const ctx = ensureAudio();
  while(nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD_SEC){
    scheduleTransportStep(transportStep, nextNoteTime);

    // advance step with swing on offbeats (drum feel) — apply to transport grid generally
    const dur = stepDurSec();
    const isOffbeat = (transportStep % 2) === 1;
    const swingAmt = Number(swing.value || 0);
    nextNoteTime += dur + (isOffbeat ? dur * swingAmt : 0);

    transportStep = (transportStep + 1) % LOOP_STEPS;
  }
}

function transportStart(){
  if(transportOn) return;
  const ctx = ensureAudio();
  ensureDrumBus();
  ensureGuitarBus();

  transportOn = true;
  playAll.disabled = true;
  stopAll.disabled = false;

  transportStatus.textContent = "playing…";
  transportStatus.classList.remove('bad');
  transportStatus.classList.add('ok');

  transportStep = 0;
  metroBeatCount = 0;
  nextNoteTime = ctx.currentTime + 0.06;
  schedulerTimer = setInterval(transportScheduler, LOOKAHEAD_MS);
  seqStatus.textContent = "playing…";
}

function transportStop(){
  transportOn = false;
  playAll.disabled = false;
  stopAll.disabled = true;

  transportStatus.textContent = "stopped";
  transportStatus.classList.remove('ok');
  transportStatus.classList.add('bad');

  clearInterval(schedulerTimer);
  schedulerTimer = null;
  drumClearPlayhead();
  seqClearPlayhead();
  seqStatus.textContent = "stopped";
}

playAll.addEventListener('click', transportStart);
stopAll.addEventListener('click', transportStop);

/* =========================================================
   Seq clear/fill buttons
========================================================= */
seqClearChords.addEventListener('click', ()=>{
  chordLane.fill(null);
  buildSeqGrid();
});
seqFillChord.addEventListener('click', ()=>{
  chordLane.fill(seqChordPick.value);
  buildSeqGrid();
});
seqClearStrings.addEventListener('click', ()=>{
  for(let s=0;s<6;s++) stringLanes[s].fill(null);
  buildSeqGrid();
});

/* =========================================================
   TUNER (mic + autocorrelation)
========================================================= */
let micStream=null, analyser=null, micSource=null, rafId=null;
const micToggle = document.getElementById('micToggle');
const micStop = document.getElementById('micStop');
const micStatus = document.getElementById('micStatus');
const noteName = document.getElementById('noteName');
const freqRead = document.getElementById('freqRead');
const centsRead = document.getElementById('centsRead');
const targetRead = document.getElementById('targetRead');
const meterBar = document.getElementById('meterBar');

const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
function freqToNote(f){
  const A4 = 440;
  const n = 12 * Math.log2(f / A4) + 69;
  const midi = Math.round(n);
  const name = NOTE_NAMES[(midi + 1200) % 12];
  const octave = Math.floor(midi/12) - 1;
  const target = A4 * Math.pow(2, (midi-69)/12);
  const cents = Math.floor(1200 * Math.log2(f/target));
  return { midi, name, octave, target, cents };
}

function autoCorrelate(buf, sampleRate){
  const SIZE = buf.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++){ const v = buf[i]; rms += v*v; }
  rms = Math.sqrt(rms / SIZE);
  if(rms < 0.01) return null;

  let r1=0, r2=SIZE-1;
  while(r1 < SIZE/2 && Math.abs(buf[r1]) < 0.01) r1++;
  while(r2 > SIZE/2 && Math.abs(buf[r2]) < 0.01) r2--;

  const trimmed = buf.slice(r1, r2);
  const N = trimmed.length;
  const c = new Array(N).fill(0);

  for(let lag=0; lag<N; lag++){
    let sum = 0;
    for(let i=0; i<N-lag; i++){
      sum += trimmed[i] * trimmed[i+lag];
    }
    c[lag] = sum;
  }

  let d=0;
  while(d < N-1 && c[d] > c[d+1]) d++;

  let maxVal = -1, maxPos = -1;
  for(let i=d; i<N; i++){
    if(c[i] > maxVal){ maxVal = c[i]; maxPos = i; }
  }
  if(maxPos <= 0) return null;

  const x1 = c[maxPos-1] ?? 0;
  const x2 = c[maxPos];
  const x3 = c[maxPos+1] ?? 0;
  const a = (x1 + x3 - 2*x2) / 2;
  const b = (x3 - x1) / 2;
  const shift = (a ? -b/(2*a) : 0);

  const period = maxPos + shift;
  const freq = sampleRate / period;
  if(!isFinite(freq) || freq < 50 || freq > 1200) return null;
  return freq;
}

async function micOn(){
  try{
    ensureAudio();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micSource = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    micSource.connect(analyser);

    micStatus.textContent = "microfono: on";
    micToggle.disabled = true;
    micStop.disabled = false;

    const buf = new Float32Array(analyser.fftSize);
    const loop = () => {
      analyser.getFloatTimeDomainData(buf);
      const f = autoCorrelate(buf, audioCtx.sampleRate);
      if(f){
        const n = freqToNote(f);
        noteName.textContent = `${n.name}${n.octave}`;
        freqRead.textContent = `${f.toFixed(2)} Hz`;
        centsRead.textContent = `${n.cents} cents`;
        targetRead.textContent = `target: ${n.target.toFixed(2)} Hz`;

        const c = Math.max(-50, Math.min(50, n.cents));
        const pct = (c / 50) * 50;
        meterBar.style.transform = `translateX(${pct-50}%)`;
      } else {
        noteName.textContent = "—";
        freqRead.textContent = "— Hz";
        centsRead.textContent = "— cents";
        targetRead.textContent = "target: —";
        meterBar.style.transform = `translateX(-50%)`;
      }
      rafId = requestAnimationFrame(loop);
    };
    loop();
  } catch(err){
    micStatus.textContent = "microfono: errore/negato";
    console.error(err);
  }
}
function micOff(){
  if(rafId) cancelAnimationFrame(rafId);
  rafId=null;
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
  }
  micStream=null;
  analyser=null;
  micSource=null;

  micStatus.textContent = "microfono: off";
  micToggle.disabled = false;
  micStop.disabled = true;
}
micToggle.addEventListener('click', micOn);
micStop.addEventListener('click', micOff);

/* =========================================================
   Studio recorder (MediaRecorder)
========================================================= */
let recStream=null, mediaRecorder=null, chunks=[];
const recStart = document.getElementById('recStart');
const recStop = document.getElementById('recStop');
const recStatus = document.getElementById('recStatus');
const playback = document.getElementById('playback');

async function startRec(){
  try{
    recStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(recStream);
    chunks = [];
    mediaRecorder.ondataavailable = (e)=> { if(e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
      playback.src = URL.createObjectURL(blob);
    };
    mediaRecorder.start();
    recStatus.textContent = "recording…";
    recStart.disabled = true;
    recStop.disabled = false;
  }catch(err){
    recStatus.textContent = "errore microfono";
    console.error(err);
  }
}
function stopRec(){
  try{ mediaRecorder && mediaRecorder.stop(); }catch(e){}
  if(recStream) recStream.getTracks().forEach(t=>t.stop());
  recStream=null;
  recStatus.textContent = "stopped";
  recStart.disabled = false;
  recStop.disabled = true;
}
recStart.addEventListener('click', startRec);
recStop.addEventListener('click', stopRec);

/* =========================================================
   Minor init
========================================================= */
setMetroEnabled(false);
setDrumEnabled(false);
setSeqEnabled(false);
updateTransportFlags();
</script>
</body>
</html>
